"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourcePart = exports.isSuperObject = exports.arrayWith = exports.exactValue = exports._objectContaining = exports.deepObjectLike = exports.objectLike = exports.HaveResourceAssertion = exports.haveResourceLike = exports.haveResource = exports.ABSENT = void 0;
const assertion_1 = require("../assertion");
/**
 * Magic value to signify that a certain key should be absent from the property bag.
 *
 * The property is either not present or set to `undefined.
 *
 * NOTE: `ABSENT` only works with the `haveResource()` and `haveResourceLike()`
 * assertions.
 */
exports.ABSENT = '{{ABSENT}}';
/**
 * An assertion to check whether a resource of a given type and with the given properties exists, disregarding properties
 *
 * @param resourceType the type of the resource that is expected to be present.
 * @param properties   the properties that the resource is expected to have. A function may be provided, in which case
 *                     it will be called with the properties of candidate resources and an ``InspectionFailure``
 *                     instance on which errors should be appended, and should return a truthy value to denote a match.
 * @param comparison   the entity that is being asserted against.
 * @param allowValueExtension if properties is an object, tells whether values must match exactly, or if they are
 *                     allowed to be supersets of the reference values. Meaningless if properties is a function.
 */
function haveResource(resourceType, properties, comparison, allowValueExtension = false) {
    return new HaveResourceAssertion(resourceType, properties, comparison, allowValueExtension);
}
exports.haveResource = haveResource;
/**
 * Sugar for calling ``haveResources`` with ``allowValueExtension`` set to ``true``.
 */
function haveResourceLike(resourceType, properties, comparison) {
    return haveResource(resourceType, properties, comparison, true);
}
exports.haveResourceLike = haveResourceLike;
class HaveResourceAssertion extends assertion_1.JestFriendlyAssertion {
    constructor(resourceType, properties, part, allowValueExtension = false) {
        super();
        this.resourceType = resourceType;
        this.inspected = [];
        this.matcher = isCallable(properties) ? properties :
            properties === undefined ? anything() :
                allowValueExtension ? deepObjectLike(properties) :
                    objectLike(properties);
        this.part = part !== undefined ? part : ResourcePart.Properties;
    }
    assertUsing(inspector) {
        for (const logicalId of Object.keys(inspector.value.Resources || {})) {
            const resource = inspector.value.Resources[logicalId];
            if (resource.Type === this.resourceType) {
                const propsToCheck = this.part === ResourcePart.Properties ? resource.Properties : resource;
                // Pass inspection object as 2nd argument, initialize failure with default string,
                // to maintain backwards compatibility with old predicate API.
                const inspection = { resource, failureReason: 'Object did not match predicate' };
                if (match(propsToCheck, this.matcher, inspection)) {
                    return true;
                }
                this.inspected.push(inspection);
            }
        }
        return false;
    }
    generateErrorMessage() {
        const lines = [];
        lines.push(`None of ${this.inspected.length} resources matches ${this.description}.`);
        for (const inspected of this.inspected) {
            lines.push(`- ${inspected.failureReason} in:`);
            lines.push(indent(4, JSON.stringify(inspected.resource, null, 2)));
        }
        return lines.join('\n');
    }
    assertOrThrow(inspector) {
        if (!this.assertUsing(inspector)) {
            throw new Error(this.generateErrorMessage());
        }
    }
    get description() {
        // tslint:disable-next-line:max-line-length
        return `resource '${this.resourceType}' with ${JSON.stringify(this.matcher, undefined, 2)}`;
    }
}
exports.HaveResourceAssertion = HaveResourceAssertion;
function indent(n, s) {
    const prefix = ' '.repeat(n);
    return prefix + s.replace(/\n/g, '\n' + prefix);
}
/**
 * Match a given literal value against a matcher
 *
 * If the matcher is a callable, use that to evaluate the value. Otherwise, the values
 * must be literally the same.
 */
function match(value, matcher, inspection) {
    if (isCallable(matcher)) {
        // Custom matcher (this mostly looks very weird because our `InspectionFailure` signature is weird)
        const innerInspection = { ...inspection, failureReason: '' };
        const result = matcher(value, innerInspection);
        if (typeof result !== 'boolean') {
            return failMatcher(inspection, `Predicate returned non-boolean return value: ${result}`);
        }
        if (!result && !innerInspection.failureReason) {
            // Custom matcher neglected to return an error
            return failMatcher(inspection, 'Predicate returned false');
        }
        // Propagate inner error in case of failure
        if (!result) {
            inspection.failureReason = innerInspection.failureReason;
        }
        return result;
    }
    return matchLiteral(value, matcher, inspection);
}
/**
 * Match a literal value at the top level.
 *
 * When recursing into arrays or objects, the nested values can be either matchers
 * or literals.
 */
function matchLiteral(value, pattern, inspection) {
    if (pattern == null) {
        return true;
    }
    const errors = new Array();
    if (Array.isArray(value) !== Array.isArray(pattern)) {
        return failMatcher(inspection, 'Array type mismatch');
    }
    if (Array.isArray(value)) {
        if (pattern.length !== value.length) {
            return failMatcher(inspection, 'Array length mismatch');
        }
        // Recurse comparison for individual objects
        for (let i = 0; i < pattern.length; i++) {
            if (!match(value[i], pattern[i], { ...inspection })) {
                errors.push(`Array element ${i} mismatch`);
            }
        }
        if (errors.length > 0) {
            return failMatcher(inspection, errors.join(', '));
        }
        return true;
    }
    if ((typeof value === 'object') !== (typeof pattern === 'object')) {
        return failMatcher(inspection, 'Object type mismatch');
    }
    if (typeof pattern === 'object') {
        // Check that all fields in the pattern have the right value
        const innerInspection = { ...inspection, failureReason: '' };
        const matcher = objectLike(pattern)(value, innerInspection);
        if (!matcher) {
            inspection.failureReason = innerInspection.failureReason;
            return false;
        }
        // Check no fields uncovered
        const realFields = new Set(Object.keys(value));
        for (const key of Object.keys(pattern)) {
            realFields.delete(key);
        }
        if (realFields.size > 0) {
            return failMatcher(inspection, `Unexpected keys present in object: ${Array.from(realFields).join(', ')}`);
        }
        return true;
    }
    if (value !== pattern) {
        return failMatcher(inspection, 'Different values');
    }
    return true;
}
/**
 * Helper function to make matcher failure reporting a little easier
 *
 * Our protocol is weird (change a string on a passed-in object and return 'false'),
 * but I don't want to change that right now.
 */
function failMatcher(inspection, error) {
    inspection.failureReason = error;
    return false;
}
/**
 * A matcher for an object that contains at least the given fields with the given matchers (or literals)
 *
 * Only does lenient matching one level deep, at the next level all objects must declare the
 * exact expected keys again.
 */
function objectLike(pattern) {
    return _objectContaining(pattern, false);
}
exports.objectLike = objectLike;
/**
 * A matcher for an object that contains at least the given fields with the given matchers (or literals)
 *
 * Switches to "deep" lenient matching. Nested objects also only need to contain declared keys.
 */
function deepObjectLike(pattern) {
    return _objectContaining(pattern, true);
}
exports.deepObjectLike = deepObjectLike;
function _objectContaining(pattern, deep) {
    const ret = (value, inspection) => {
        if (typeof value !== 'object' || !value) {
            return failMatcher(inspection, `Expect an object but got '${typeof value}'`);
        }
        const errors = new Array();
        for (const [patternKey, patternValue] of Object.entries(pattern)) {
            if (patternValue === exports.ABSENT) {
                if (value[patternKey] !== undefined) {
                    errors.push(`Field ${patternKey} present, but shouldn't be`);
                }
                continue;
            }
            if (!(patternKey in value)) {
                errors.push(`Field ${patternKey} missing`);
                continue;
            }
            // If we are doing DEEP objectLike, translate object literals in the pattern into
            // more `deepObjectLike` matchers, even if they occur in lists.
            const matchValue = deep ? deepMatcherFromObjectLiteral(patternValue) : patternValue;
            const innerInspection = { ...inspection, failureReason: '' };
            const valueMatches = match(value[patternKey], matchValue, innerInspection);
            if (!valueMatches) {
                errors.push(`Field ${patternKey} mismatch: ${innerInspection.failureReason}`);
            }
        }
        /**
         * Transform nested object literals into more deep object matchers, if applicable
         *
         * Object literals in lists are also transformed.
         */
        function deepMatcherFromObjectLiteral(nestedPattern) {
            if (isObject(nestedPattern)) {
                return deepObjectLike(nestedPattern);
            }
            if (Array.isArray(nestedPattern)) {
                return nestedPattern.map(deepMatcherFromObjectLiteral);
            }
            return nestedPattern;
        }
        if (errors.length > 0) {
            return failMatcher(inspection, errors.join(', '));
        }
        return true;
    };
    // Override toJSON so that our error messages print an readable version of this matcher
    // (which we produce by doing JSON.stringify() at some point in the future).
    ret.toJSON = () => ({ [deep ? '$deepObjectLike' : '$objectLike']: pattern });
    return ret;
}
exports._objectContaining = _objectContaining;
/**
 * Match exactly the given value
 *
 * This is the default, you only need this to escape from the deep lenient matching
 * of `deepObjectLike`.
 */
function exactValue(expected) {
    const ret = (value, inspection) => {
        return matchLiteral(value, expected, inspection);
    };
    // Override toJSON so that our error messages print an readable version of this matcher
    // (which we produce by doing JSON.stringify() at some point in the future).
    ret.toJSON = () => ({ $exactValue: expected });
    return ret;
}
exports.exactValue = exactValue;
/**
 * A matcher for a list that contains all of the given elements in any order
 */
function arrayWith(...elements) {
    if (elements.length === 0) {
        return anything();
    }
    const ret = (value, inspection) => {
        if (!Array.isArray(value)) {
            return failMatcher(inspection, `Expect an array but got '${typeof value}'`);
        }
        for (const element of elements) {
            const failure = longestFailure(value, element);
            if (failure) {
                return failMatcher(inspection, `Array did not contain expected element, closest match at index ${failure[0]}: ${failure[1]}`);
            }
        }
        return true;
        /**
         * Return 'null' if the matcher matches anywhere in the array, otherwise the longest error and its index
         */
        function longestFailure(array, matcher) {
            let fail = null;
            for (let i = 0; i < array.length; i++) {
                const innerInspection = { ...inspection, failureReason: '' };
                if (match(array[i], matcher, innerInspection)) {
                    return null;
                }
                if (fail === null || innerInspection.failureReason.length > fail[1].length) {
                    fail = [i, innerInspection.failureReason];
                }
            }
            return fail;
        }
    };
    // Override toJSON so that our error messages print an readable version of this matcher
    // (which we produce by doing JSON.stringify() at some point in the future).
    ret.toJSON = () => ({ $arrayContaining: elements.length === 1 ? elements[0] : elements });
    return ret;
}
exports.arrayWith = arrayWith;
/**
 * Matches anything
 */
function anything() {
    const ret = () => {
        return true;
    };
    ret.toJSON = () => ({ $anything: true });
    return ret;
}
/**
 * Return whether `superObj` is a super-object of `obj`.
 *
 * A super-object has the same or more property values, recursing into sub properties if ``allowValueExtension`` is true.
 *
 * At any point in the object, a value may be replaced with a function which will be used to check that particular field.
 * The type of a matcher function is expected to be of type PropertyMatcher.
 *
 * @deprecated - Use `objectLike` or a literal object instead.
 */
function isSuperObject(superObj, pattern, errors = [], allowValueExtension = false) {
    const matcher = allowValueExtension ? deepObjectLike(pattern) : objectLike(pattern);
    const inspection = { resource: superObj, failureReason: '' };
    const ret = match(superObj, matcher, inspection);
    if (!ret) {
        errors.push(inspection.failureReason);
    }
    return ret;
}
exports.isSuperObject = isSuperObject;
/**
 * What part of the resource to compare
 */
var ResourcePart;
(function (ResourcePart) {
    /**
     * Only compare the resource's properties
     */
    ResourcePart[ResourcePart["Properties"] = 0] = "Properties";
    /**
     * Check the entire CloudFormation config
     *
     * (including UpdateConfig, DependsOn, etc.)
     */
    ResourcePart[ResourcePart["CompleteDefinition"] = 1] = "CompleteDefinition";
})(ResourcePart = exports.ResourcePart || (exports.ResourcePart = {}));
/**
 * Whether a value is a callable
 */
function isCallable(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Whether a value is an object
 */
function isObject(x) {
    // Because `typeof null === 'object'`.
    return x && typeof x === 'object';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGF2ZS1yZXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhdmUtcmVzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNENBQWdFO0FBR2hFOzs7Ozs7O0dBT0c7QUFDVSxRQUFBLE1BQU0sR0FBRyxZQUFZLENBQUM7QUFFbkM7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQWdCLFlBQVksQ0FDMUIsWUFBb0IsRUFDcEIsVUFBZ0IsRUFDaEIsVUFBeUIsRUFDekIsc0JBQStCLEtBQUs7SUFDcEMsT0FBTyxJQUFJLHFCQUFxQixDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLG1CQUFtQixDQUFDLENBQUM7QUFDOUYsQ0FBQztBQU5ELG9DQU1DO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixnQkFBZ0IsQ0FDOUIsWUFBb0IsRUFDcEIsVUFBZ0IsRUFDaEIsVUFBeUI7SUFDekIsT0FBTyxZQUFZLENBQUMsWUFBWSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQUxELDRDQUtDO0FBSUQsTUFBYSxxQkFBc0IsU0FBUSxpQ0FBcUM7SUFLOUUsWUFDbUIsWUFBb0IsRUFDckMsVUFBZ0IsRUFDaEIsSUFBbUIsRUFDbkIsc0JBQStCLEtBQUs7UUFDcEMsS0FBSyxFQUFFLENBQUM7UUFKUyxpQkFBWSxHQUFaLFlBQVksQ0FBUTtRQUx0QixjQUFTLEdBQXdCLEVBQUUsQ0FBQztRQVduRCxJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEQsVUFBVSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztnQkFDckMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO29CQUNoRCxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUM7SUFDbEUsQ0FBQztJQUVNLFdBQVcsQ0FBQyxTQUF5QjtRQUMxQyxLQUFLLE1BQU0sU0FBUyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDLEVBQUU7WUFDcEUsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDdEQsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ3ZDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO2dCQUU1RixrRkFBa0Y7Z0JBQ2xGLDhEQUE4RDtnQkFDOUQsTUFBTSxVQUFVLEdBQUcsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLGdDQUFnQyxFQUFFLENBQUM7Z0JBRWpGLElBQUksS0FBSyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxFQUFFO29CQUNqRCxPQUFPLElBQUksQ0FBQztpQkFDYjtnQkFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNqQztTQUNGO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU0sb0JBQW9CO1FBQ3pCLE1BQU0sS0FBSyxHQUFhLEVBQUUsQ0FBQztRQUMzQixLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLHNCQUFzQixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztRQUV0RixLQUFLLE1BQU0sU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDdEMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVMsQ0FBQyxhQUFhLE1BQU0sQ0FBQyxDQUFDO1lBQy9DLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwRTtRQUVELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRU0sYUFBYSxDQUFDLFNBQXlCO1FBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUMsQ0FBQztTQUM5QztJQUNILENBQUM7SUFFRCxJQUFXLFdBQVc7UUFDcEIsMkNBQTJDO1FBQzNDLE9BQU8sYUFBYSxJQUFJLENBQUMsWUFBWSxVQUFVLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5RixDQUFDO0NBQ0Y7QUE5REQsc0RBOERDO0FBRUQsU0FBUyxNQUFNLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFDbEMsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixPQUFPLE1BQU0sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQU9EOzs7OztHQUtHO0FBQ0gsU0FBUyxLQUFLLENBQUMsS0FBVSxFQUFFLE9BQVksRUFBRSxVQUE2QjtJQUNwRSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUN2QixtR0FBbUc7UUFDbkcsTUFBTSxlQUFlLEdBQXNCLEVBQUUsR0FBRyxVQUFVLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQ2hGLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFDL0MsSUFBSSxPQUFPLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDL0IsT0FBTyxXQUFXLENBQUMsVUFBVSxFQUFFLGdEQUFnRCxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQzFGO1FBQ0QsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLEVBQUU7WUFDN0MsOENBQThDO1lBQzlDLE9BQU8sV0FBVyxDQUFDLFVBQVUsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsMkNBQTJDO1FBQzNDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFBRSxVQUFVLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQyxhQUFhLENBQUM7U0FBRTtRQUMxRSxPQUFPLE1BQU0sQ0FBQztLQUNmO0lBRUQsT0FBTyxZQUFZLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLFlBQVksQ0FBQyxLQUFVLEVBQUUsT0FBWSxFQUFFLFVBQTZCO0lBQzNFLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDO0tBQUU7SUFFckMsTUFBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztJQUVuQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUNuRCxPQUFPLFdBQVcsQ0FBQyxVQUFVLEVBQUUscUJBQXFCLENBQUMsQ0FBQztLQUN2RDtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN4QixJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNuQyxPQUFPLFdBQVcsQ0FBQyxVQUFVLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztTQUN6RDtRQUVELDRDQUE0QztRQUM1QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLFVBQVUsRUFBRSxDQUFDLEVBQUU7Z0JBQ25ELE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDNUM7U0FDRjtRQUVELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsT0FBTyxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNuRDtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLENBQUMsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLE9BQU8sS0FBSyxRQUFRLENBQUMsRUFBRTtRQUNqRSxPQUFPLFdBQVcsQ0FBQyxVQUFVLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztLQUN4RDtJQUNELElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1FBQy9CLDREQUE0RDtRQUM1RCxNQUFNLGVBQWUsR0FBRyxFQUFFLEdBQUcsVUFBVSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUM3RCxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBQzVELElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixVQUFVLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQyxhQUFhLENBQUM7WUFDekQsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELDRCQUE0QjtRQUM1QixNQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDL0MsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUFFO1FBQ25FLElBQUksVUFBVSxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUU7WUFDdkIsT0FBTyxXQUFXLENBQUMsVUFBVSxFQUFFLHNDQUFzQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDM0c7UUFDRCxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsSUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFO1FBQ3JCLE9BQU8sV0FBVyxDQUFDLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0tBQ3BEO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLFdBQVcsQ0FBQyxVQUE2QixFQUFFLEtBQWE7SUFDL0QsVUFBVSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDakMsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixVQUFVLENBQW1CLE9BQVU7SUFDckQsT0FBTyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUZELGdDQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLGNBQWMsQ0FBbUIsT0FBVTtJQUN6RCxPQUFPLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBRkQsd0NBRUM7QUFFRCxTQUFnQixpQkFBaUIsQ0FBbUIsT0FBVSxFQUFFLElBQWE7SUFDM0UsTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFVLEVBQUUsVUFBNkIsRUFBVyxFQUFFO1FBQ2pFLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3ZDLE9BQU8sV0FBVyxDQUFDLFVBQVUsRUFBRSw2QkFBNkIsT0FBTyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1NBQzlFO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztRQUVuQyxLQUFLLE1BQU0sQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNoRSxJQUFJLFlBQVksS0FBSyxjQUFNLEVBQUU7Z0JBQzNCLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLFNBQVMsRUFBRTtvQkFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsVUFBVSw0QkFBNEIsQ0FBQyxDQUFDO2lCQUFFO2dCQUN0RyxTQUFTO2FBQ1Y7WUFFRCxJQUFJLENBQUMsQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLEVBQUU7Z0JBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxVQUFVLFVBQVUsQ0FBQyxDQUFDO2dCQUMzQyxTQUFTO2FBQ1Y7WUFFRCxpRkFBaUY7WUFDakYsK0RBQStEO1lBQy9ELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsNEJBQTRCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztZQUVwRixNQUFNLGVBQWUsR0FBRyxFQUFFLEdBQUcsVUFBVSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUM3RCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxlQUFlLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNqQixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsVUFBVSxjQUFjLGVBQWUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO2FBQy9FO1NBQ0Y7UUFFRDs7OztXQUlHO1FBQ0gsU0FBUyw0QkFBNEIsQ0FBQyxhQUFrQjtZQUN0RCxJQUFJLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDM0IsT0FBTyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDdEM7WUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sYUFBYSxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO2FBQ3hEO1lBQ0QsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsT0FBTyxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNuRDtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQyxDQUFDO0lBRUYsdUZBQXVGO0lBQ3ZGLDRFQUE0RTtJQUM1RSxHQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDN0UsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBdkRELDhDQXVEQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLFFBQWE7SUFDdEMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFVLEVBQUUsVUFBNkIsRUFBVyxFQUFFO1FBQ2pFLE9BQU8sWUFBWSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbkQsQ0FBQyxDQUFDO0lBRUYsdUZBQXVGO0lBQ3ZGLDRFQUE0RTtJQUM1RSxHQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUMvQyxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFURCxnQ0FTQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLEdBQUcsUUFBZTtJQUMxQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQUUsT0FBTyxRQUFRLEVBQUUsQ0FBQztLQUFFO0lBRWpELE1BQU0sR0FBRyxHQUFHLENBQUMsS0FBVSxFQUFFLFVBQTZCLEVBQVcsRUFBRTtRQUNqRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN6QixPQUFPLFdBQVcsQ0FBQyxVQUFVLEVBQUUsNEJBQTRCLE9BQU8sS0FBSyxHQUFHLENBQUMsQ0FBQztTQUM3RTtRQUVELEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFO1lBQzlCLE1BQU0sT0FBTyxHQUFHLGNBQWMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDL0MsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsT0FBTyxXQUFXLENBQUMsVUFBVSxFQUFFLGtFQUFrRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUMvSDtTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUM7UUFFWjs7V0FFRztRQUNILFNBQVMsY0FBYyxDQUFDLEtBQVksRUFBRSxPQUFZO1lBQ2hELElBQUksSUFBSSxHQUE0QixJQUFJLENBQUM7WUFDekMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JDLE1BQU0sZUFBZSxHQUFHLEVBQUUsR0FBRyxVQUFVLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBRSxDQUFDO2dCQUM3RCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxFQUFFO29CQUM3QyxPQUFPLElBQUksQ0FBQztpQkFDYjtnQkFFRCxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksZUFBZSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRTtvQkFDMUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztpQkFDM0M7YUFDRjtZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUMsQ0FBQztJQUVGLHVGQUF1RjtJQUN2Riw0RUFBNEU7SUFDNUUsR0FBRyxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUMxRixPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUF4Q0QsOEJBd0NDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFFBQVE7SUFDZixNQUFNLEdBQUcsR0FBRyxHQUFHLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQztJQUNkLENBQUMsQ0FBQztJQUNGLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3pDLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLGFBQWEsQ0FBQyxRQUFhLEVBQUUsT0FBWSxFQUFFLFNBQW1CLEVBQUUsRUFBRSxzQkFBK0IsS0FBSztJQUNwSCxNQUFNLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFcEYsTUFBTSxVQUFVLEdBQXNCLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDaEYsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDakQsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0tBQ3ZDO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBVEQsc0NBU0M7QUFFRDs7R0FFRztBQUNILElBQVksWUFZWDtBQVpELFdBQVksWUFBWTtJQUN0Qjs7T0FFRztJQUNILDJEQUFVLENBQUE7SUFFVjs7OztPQUlHO0lBQ0gsMkVBQWtCLENBQUE7QUFDcEIsQ0FBQyxFQVpXLFlBQVksR0FBWixvQkFBWSxLQUFaLG9CQUFZLFFBWXZCO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFVBQVUsQ0FBQyxDQUFNO0lBQ3hCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLG1CQUFtQixDQUFDO0FBQzFELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsUUFBUSxDQUFDLENBQU07SUFDdEIsc0NBQXNDO0lBQ3RDLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQztBQUNwQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXNzZXJ0aW9uLCBKZXN0RnJpZW5kbHlBc3NlcnRpb24gfSBmcm9tICcuLi9hc3NlcnRpb24nO1xuaW1wb3J0IHsgU3RhY2tJbnNwZWN0b3IgfSBmcm9tICcuLi9pbnNwZWN0b3InO1xuXG4vKipcbiAqIE1hZ2ljIHZhbHVlIHRvIHNpZ25pZnkgdGhhdCBhIGNlcnRhaW4ga2V5IHNob3VsZCBiZSBhYnNlbnQgZnJvbSB0aGUgcHJvcGVydHkgYmFnLlxuICpcbiAqIFRoZSBwcm9wZXJ0eSBpcyBlaXRoZXIgbm90IHByZXNlbnQgb3Igc2V0IHRvIGB1bmRlZmluZWQuXG4gKlxuICogTk9URTogYEFCU0VOVGAgb25seSB3b3JrcyB3aXRoIHRoZSBgaGF2ZVJlc291cmNlKClgIGFuZCBgaGF2ZVJlc291cmNlTGlrZSgpYFxuICogYXNzZXJ0aW9ucy5cbiAqL1xuZXhwb3J0IGNvbnN0IEFCU0VOVCA9ICd7e0FCU0VOVH19JztcblxuLyoqXG4gKiBBbiBhc3NlcnRpb24gdG8gY2hlY2sgd2hldGhlciBhIHJlc291cmNlIG9mIGEgZ2l2ZW4gdHlwZSBhbmQgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcyBleGlzdHMsIGRpc3JlZ2FyZGluZyBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHJlc291cmNlVHlwZSB0aGUgdHlwZSBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHByb3BlcnRpZXMgICB0aGUgcHJvcGVydGllcyB0aGF0IHRoZSByZXNvdXJjZSBpcyBleHBlY3RlZCB0byBoYXZlLiBBIGZ1bmN0aW9uIG1heSBiZSBwcm92aWRlZCwgaW4gd2hpY2ggY2FzZVxuICogICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGNhbmRpZGF0ZSByZXNvdXJjZXMgYW5kIGFuIGBgSW5zcGVjdGlvbkZhaWx1cmVgYFxuICogICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSBvbiB3aGljaCBlcnJvcnMgc2hvdWxkIGJlIGFwcGVuZGVkLCBhbmQgc2hvdWxkIHJldHVybiBhIHRydXRoeSB2YWx1ZSB0byBkZW5vdGUgYSBtYXRjaC5cbiAqIEBwYXJhbSBjb21wYXJpc29uICAgdGhlIGVudGl0eSB0aGF0IGlzIGJlaW5nIGFzc2VydGVkIGFnYWluc3QuXG4gKiBAcGFyYW0gYWxsb3dWYWx1ZUV4dGVuc2lvbiBpZiBwcm9wZXJ0aWVzIGlzIGFuIG9iamVjdCwgdGVsbHMgd2hldGhlciB2YWx1ZXMgbXVzdCBtYXRjaCBleGFjdGx5LCBvciBpZiB0aGV5IGFyZVxuICogICAgICAgICAgICAgICAgICAgICBhbGxvd2VkIHRvIGJlIHN1cGVyc2V0cyBvZiB0aGUgcmVmZXJlbmNlIHZhbHVlcy4gTWVhbmluZ2xlc3MgaWYgcHJvcGVydGllcyBpcyBhIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGF2ZVJlc291cmNlKFxuICByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgcHJvcGVydGllcz86IGFueSxcbiAgY29tcGFyaXNvbj86IFJlc291cmNlUGFydCxcbiAgYWxsb3dWYWx1ZUV4dGVuc2lvbjogYm9vbGVhbiA9IGZhbHNlKTogQXNzZXJ0aW9uPFN0YWNrSW5zcGVjdG9yPiB7XG4gIHJldHVybiBuZXcgSGF2ZVJlc291cmNlQXNzZXJ0aW9uKHJlc291cmNlVHlwZSwgcHJvcGVydGllcywgY29tcGFyaXNvbiwgYWxsb3dWYWx1ZUV4dGVuc2lvbik7XG59XG5cbi8qKlxuICogU3VnYXIgZm9yIGNhbGxpbmcgYGBoYXZlUmVzb3VyY2VzYGAgd2l0aCBgYGFsbG93VmFsdWVFeHRlbnNpb25gYCBzZXQgdG8gYGB0cnVlYGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXZlUmVzb3VyY2VMaWtlKFxuICByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgcHJvcGVydGllcz86IGFueSxcbiAgY29tcGFyaXNvbj86IFJlc291cmNlUGFydCkge1xuICByZXR1cm4gaGF2ZVJlc291cmNlKHJlc291cmNlVHlwZSwgcHJvcGVydGllcywgY29tcGFyaXNvbiwgdHJ1ZSk7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5TWF0Y2hlciA9IChwcm9wczogYW55LCBpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSkgPT4gYm9vbGVhbjtcblxuZXhwb3J0IGNsYXNzIEhhdmVSZXNvdXJjZUFzc2VydGlvbiBleHRlbmRzIEplc3RGcmllbmRseUFzc2VydGlvbjxTdGFja0luc3BlY3Rvcj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IGluc3BlY3RlZDogSW5zcGVjdGlvbkZhaWx1cmVbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhcnQ6IFJlc291cmNlUGFydDtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXRjaGVyOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgICBwcm9wZXJ0aWVzPzogYW55LFxuICAgIHBhcnQ/OiBSZXNvdXJjZVBhcnQsXG4gICAgYWxsb3dWYWx1ZUV4dGVuc2lvbjogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMubWF0Y2hlciA9IGlzQ2FsbGFibGUocHJvcGVydGllcykgPyBwcm9wZXJ0aWVzIDpcbiAgICAgIHByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IGFueXRoaW5nKCkgOlxuICAgICAgICBhbGxvd1ZhbHVlRXh0ZW5zaW9uID8gZGVlcE9iamVjdExpa2UocHJvcGVydGllcykgOlxuICAgICAgICAgIG9iamVjdExpa2UocHJvcGVydGllcyk7XG4gICAgdGhpcy5wYXJ0ID0gcGFydCAhPT0gdW5kZWZpbmVkID8gcGFydCA6IFJlc291cmNlUGFydC5Qcm9wZXJ0aWVzO1xuICB9XG5cbiAgcHVibGljIGFzc2VydFVzaW5nKGluc3BlY3RvcjogU3RhY2tJbnNwZWN0b3IpOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IGxvZ2ljYWxJZCBvZiBPYmplY3Qua2V5cyhpbnNwZWN0b3IudmFsdWUuUmVzb3VyY2VzIHx8IHt9KSkge1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBpbnNwZWN0b3IudmFsdWUuUmVzb3VyY2VzW2xvZ2ljYWxJZF07XG4gICAgICBpZiAocmVzb3VyY2UuVHlwZSA9PT0gdGhpcy5yZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgY29uc3QgcHJvcHNUb0NoZWNrID0gdGhpcy5wYXJ0ID09PSBSZXNvdXJjZVBhcnQuUHJvcGVydGllcyA/IHJlc291cmNlLlByb3BlcnRpZXMgOiByZXNvdXJjZTtcblxuICAgICAgICAvLyBQYXNzIGluc3BlY3Rpb24gb2JqZWN0IGFzIDJuZCBhcmd1bWVudCwgaW5pdGlhbGl6ZSBmYWlsdXJlIHdpdGggZGVmYXVsdCBzdHJpbmcsXG4gICAgICAgIC8vIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIHByZWRpY2F0ZSBBUEkuXG4gICAgICAgIGNvbnN0IGluc3BlY3Rpb24gPSB7IHJlc291cmNlLCBmYWlsdXJlUmVhc29uOiAnT2JqZWN0IGRpZCBub3QgbWF0Y2ggcHJlZGljYXRlJyB9O1xuXG4gICAgICAgIGlmIChtYXRjaChwcm9wc1RvQ2hlY2ssIHRoaXMubWF0Y2hlciwgaW5zcGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5zcGVjdGVkLnB1c2goaW5zcGVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdlbmVyYXRlRXJyb3JNZXNzYWdlKCkge1xuICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxpbmVzLnB1c2goYE5vbmUgb2YgJHt0aGlzLmluc3BlY3RlZC5sZW5ndGh9IHJlc291cmNlcyBtYXRjaGVzICR7dGhpcy5kZXNjcmlwdGlvbn0uYCk7XG5cbiAgICBmb3IgKGNvbnN0IGluc3BlY3RlZCBvZiB0aGlzLmluc3BlY3RlZCkge1xuICAgICAgbGluZXMucHVzaChgLSAke2luc3BlY3RlZC5mYWlsdXJlUmVhc29ufSBpbjpgKTtcbiAgICAgIGxpbmVzLnB1c2goaW5kZW50KDQsIEpTT04uc3RyaW5naWZ5KGluc3BlY3RlZC5yZXNvdXJjZSwgbnVsbCwgMikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gIH1cblxuICBwdWJsaWMgYXNzZXJ0T3JUaHJvdyhpbnNwZWN0b3I6IFN0YWNrSW5zcGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmFzc2VydFVzaW5nKGluc3BlY3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdlbmVyYXRlRXJyb3JNZXNzYWdlKCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgcmV0dXJuIGByZXNvdXJjZSAnJHt0aGlzLnJlc291cmNlVHlwZX0nIHdpdGggJHtKU09OLnN0cmluZ2lmeSh0aGlzLm1hdGNoZXIsIHVuZGVmaW5lZCwgMil9YDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRlbnQobjogbnVtYmVyLCBzOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gJyAnLnJlcGVhdChuKTtcbiAgcmV0dXJuIHByZWZpeCArIHMucmVwbGFjZSgvXFxuL2csICdcXG4nICsgcHJlZml4KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnNwZWN0aW9uRmFpbHVyZSB7XG4gIHJlc291cmNlOiBhbnk7XG4gIGZhaWx1cmVSZWFzb246IHN0cmluZztcbn1cblxuLyoqXG4gKiBNYXRjaCBhIGdpdmVuIGxpdGVyYWwgdmFsdWUgYWdhaW5zdCBhIG1hdGNoZXJcbiAqXG4gKiBJZiB0aGUgbWF0Y2hlciBpcyBhIGNhbGxhYmxlLCB1c2UgdGhhdCB0byBldmFsdWF0ZSB0aGUgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlc1xuICogbXVzdCBiZSBsaXRlcmFsbHkgdGhlIHNhbWUuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKHZhbHVlOiBhbnksIG1hdGNoZXI6IGFueSwgaW5zcGVjdGlvbjogSW5zcGVjdGlvbkZhaWx1cmUpIHtcbiAgaWYgKGlzQ2FsbGFibGUobWF0Y2hlcikpIHtcbiAgICAvLyBDdXN0b20gbWF0Y2hlciAodGhpcyBtb3N0bHkgbG9va3MgdmVyeSB3ZWlyZCBiZWNhdXNlIG91ciBgSW5zcGVjdGlvbkZhaWx1cmVgIHNpZ25hdHVyZSBpcyB3ZWlyZClcbiAgICBjb25zdCBpbm5lckluc3BlY3Rpb246IEluc3BlY3Rpb25GYWlsdXJlID0geyAuLi5pbnNwZWN0aW9uLCBmYWlsdXJlUmVhc29uOiAnJyB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIodmFsdWUsIGlubmVySW5zcGVjdGlvbik7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIGZhaWxNYXRjaGVyKGluc3BlY3Rpb24sIGBQcmVkaWNhdGUgcmV0dXJuZWQgbm9uLWJvb2xlYW4gcmV0dXJuIHZhbHVlOiAke3Jlc3VsdH1gKTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQgJiYgIWlubmVySW5zcGVjdGlvbi5mYWlsdXJlUmVhc29uKSB7XG4gICAgICAvLyBDdXN0b20gbWF0Y2hlciBuZWdsZWN0ZWQgdG8gcmV0dXJuIGFuIGVycm9yXG4gICAgICByZXR1cm4gZmFpbE1hdGNoZXIoaW5zcGVjdGlvbiwgJ1ByZWRpY2F0ZSByZXR1cm5lZCBmYWxzZScpO1xuICAgIH1cbiAgICAvLyBQcm9wYWdhdGUgaW5uZXIgZXJyb3IgaW4gY2FzZSBvZiBmYWlsdXJlXG4gICAgaWYgKCFyZXN1bHQpIHsgaW5zcGVjdGlvbi5mYWlsdXJlUmVhc29uID0gaW5uZXJJbnNwZWN0aW9uLmZhaWx1cmVSZWFzb247IH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoTGl0ZXJhbCh2YWx1ZSwgbWF0Y2hlciwgaW5zcGVjdGlvbik7XG59XG5cbi8qKlxuICogTWF0Y2ggYSBsaXRlcmFsIHZhbHVlIGF0IHRoZSB0b3AgbGV2ZWwuXG4gKlxuICogV2hlbiByZWN1cnNpbmcgaW50byBhcnJheXMgb3Igb2JqZWN0cywgdGhlIG5lc3RlZCB2YWx1ZXMgY2FuIGJlIGVpdGhlciBtYXRjaGVyc1xuICogb3IgbGl0ZXJhbHMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoTGl0ZXJhbCh2YWx1ZTogYW55LCBwYXR0ZXJuOiBhbnksIGluc3BlY3Rpb246IEluc3BlY3Rpb25GYWlsdXJlKSB7XG4gIGlmIChwYXR0ZXJuID09IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cblxuICBjb25zdCBlcnJvcnMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAhPT0gQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBmYWlsTWF0Y2hlcihpbnNwZWN0aW9uLCAnQXJyYXkgdHlwZSBtaXNtYXRjaCcpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCAhPT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFpbE1hdGNoZXIoaW5zcGVjdGlvbiwgJ0FycmF5IGxlbmd0aCBtaXNtYXRjaCcpO1xuICAgIH1cblxuICAgIC8vIFJlY3Vyc2UgY29tcGFyaXNvbiBmb3IgaW5kaXZpZHVhbCBvYmplY3RzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW1hdGNoKHZhbHVlW2ldLCBwYXR0ZXJuW2ldLCB7IC4uLmluc3BlY3Rpb24gfSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYEFycmF5IGVsZW1lbnQgJHtpfSBtaXNtYXRjaGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhaWxNYXRjaGVyKGluc3BlY3Rpb24sIGVycm9ycy5qb2luKCcsICcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSAhPT0gKHR5cGVvZiBwYXR0ZXJuID09PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gZmFpbE1hdGNoZXIoaW5zcGVjdGlvbiwgJ09iamVjdCB0eXBlIG1pc21hdGNoJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENoZWNrIHRoYXQgYWxsIGZpZWxkcyBpbiB0aGUgcGF0dGVybiBoYXZlIHRoZSByaWdodCB2YWx1ZVxuICAgIGNvbnN0IGlubmVySW5zcGVjdGlvbiA9IHsgLi4uaW5zcGVjdGlvbiwgZmFpbHVyZVJlYXNvbjogJycgfTtcbiAgICBjb25zdCBtYXRjaGVyID0gb2JqZWN0TGlrZShwYXR0ZXJuKSh2YWx1ZSwgaW5uZXJJbnNwZWN0aW9uKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIGluc3BlY3Rpb24uZmFpbHVyZVJlYXNvbiA9IGlubmVySW5zcGVjdGlvbi5mYWlsdXJlUmVhc29uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIG5vIGZpZWxkcyB1bmNvdmVyZWRcbiAgICBjb25zdCByZWFsRmllbGRzID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhdHRlcm4pKSB7IHJlYWxGaWVsZHMuZGVsZXRlKGtleSk7IH1cbiAgICBpZiAocmVhbEZpZWxkcy5zaXplID4gMCkge1xuICAgICAgcmV0dXJuIGZhaWxNYXRjaGVyKGluc3BlY3Rpb24sIGBVbmV4cGVjdGVkIGtleXMgcHJlc2VudCBpbiBvYmplY3Q6ICR7QXJyYXkuZnJvbShyZWFsRmllbGRzKS5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gcGF0dGVybikge1xuICAgIHJldHVybiBmYWlsTWF0Y2hlcihpbnNwZWN0aW9uLCAnRGlmZmVyZW50IHZhbHVlcycpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIG1ha2UgbWF0Y2hlciBmYWlsdXJlIHJlcG9ydGluZyBhIGxpdHRsZSBlYXNpZXJcbiAqXG4gKiBPdXIgcHJvdG9jb2wgaXMgd2VpcmQgKGNoYW5nZSBhIHN0cmluZyBvbiBhIHBhc3NlZC1pbiBvYmplY3QgYW5kIHJldHVybiAnZmFsc2UnKSxcbiAqIGJ1dCBJIGRvbid0IHdhbnQgdG8gY2hhbmdlIHRoYXQgcmlnaHQgbm93LlxuICovXG5mdW5jdGlvbiBmYWlsTWF0Y2hlcihpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSwgZXJyb3I6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpbnNwZWN0aW9uLmZhaWx1cmVSZWFzb24gPSBlcnJvcjtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgbWF0Y2hlciBmb3IgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYXQgbGVhc3QgdGhlIGdpdmVuIGZpZWxkcyB3aXRoIHRoZSBnaXZlbiBtYXRjaGVycyAob3IgbGl0ZXJhbHMpXG4gKlxuICogT25seSBkb2VzIGxlbmllbnQgbWF0Y2hpbmcgb25lIGxldmVsIGRlZXAsIGF0IHRoZSBuZXh0IGxldmVsIGFsbCBvYmplY3RzIG11c3QgZGVjbGFyZSB0aGVcbiAqIGV4YWN0IGV4cGVjdGVkIGtleXMgYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RMaWtlPEEgZXh0ZW5kcyBvYmplY3Q+KHBhdHRlcm46IEEpOiBQcm9wZXJ0eU1hdGNoZXIge1xuICByZXR1cm4gX29iamVjdENvbnRhaW5pbmcocGF0dGVybiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEEgbWF0Y2hlciBmb3IgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYXQgbGVhc3QgdGhlIGdpdmVuIGZpZWxkcyB3aXRoIHRoZSBnaXZlbiBtYXRjaGVycyAob3IgbGl0ZXJhbHMpXG4gKlxuICogU3dpdGNoZXMgdG8gXCJkZWVwXCIgbGVuaWVudCBtYXRjaGluZy4gTmVzdGVkIG9iamVjdHMgYWxzbyBvbmx5IG5lZWQgdG8gY29udGFpbiBkZWNsYXJlZCBrZXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcE9iamVjdExpa2U8QSBleHRlbmRzIG9iamVjdD4ocGF0dGVybjogQSk6IFByb3BlcnR5TWF0Y2hlciB7XG4gIHJldHVybiBfb2JqZWN0Q29udGFpbmluZyhwYXR0ZXJuLCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9vYmplY3RDb250YWluaW5nPEEgZXh0ZW5kcyBvYmplY3Q+KHBhdHRlcm46IEEsIGRlZXA6IGJvb2xlYW4pOiBQcm9wZXJ0eU1hdGNoZXIge1xuICBjb25zdCByZXQgPSAodmFsdWU6IGFueSwgaW5zcGVjdGlvbjogSW5zcGVjdGlvbkZhaWx1cmUpOiBib29sZWFuID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWlsTWF0Y2hlcihpbnNwZWN0aW9uLCBgRXhwZWN0IGFuIG9iamVjdCBidXQgZ290ICcke3R5cGVvZiB2YWx1ZX0nYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgW3BhdHRlcm5LZXksIHBhdHRlcm5WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGF0dGVybikpIHtcbiAgICAgIGlmIChwYXR0ZXJuVmFsdWUgPT09IEFCU0VOVCkge1xuICAgICAgICBpZiAodmFsdWVbcGF0dGVybktleV0gIT09IHVuZGVmaW5lZCkgeyBlcnJvcnMucHVzaChgRmllbGQgJHtwYXR0ZXJuS2V5fSBwcmVzZW50LCBidXQgc2hvdWxkbid0IGJlYCk7IH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHBhdHRlcm5LZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBGaWVsZCAke3BhdHRlcm5LZXl9IG1pc3NpbmdgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGFyZSBkb2luZyBERUVQIG9iamVjdExpa2UsIHRyYW5zbGF0ZSBvYmplY3QgbGl0ZXJhbHMgaW4gdGhlIHBhdHRlcm4gaW50b1xuICAgICAgLy8gbW9yZSBgZGVlcE9iamVjdExpa2VgIG1hdGNoZXJzLCBldmVuIGlmIHRoZXkgb2NjdXIgaW4gbGlzdHMuXG4gICAgICBjb25zdCBtYXRjaFZhbHVlID0gZGVlcCA/IGRlZXBNYXRjaGVyRnJvbU9iamVjdExpdGVyYWwocGF0dGVyblZhbHVlKSA6IHBhdHRlcm5WYWx1ZTtcblxuICAgICAgY29uc3QgaW5uZXJJbnNwZWN0aW9uID0geyAuLi5pbnNwZWN0aW9uLCBmYWlsdXJlUmVhc29uOiAnJyB9O1xuICAgICAgY29uc3QgdmFsdWVNYXRjaGVzID0gbWF0Y2godmFsdWVbcGF0dGVybktleV0sIG1hdGNoVmFsdWUsIGlubmVySW5zcGVjdGlvbik7XG4gICAgICBpZiAoIXZhbHVlTWF0Y2hlcykge1xuICAgICAgICBlcnJvcnMucHVzaChgRmllbGQgJHtwYXR0ZXJuS2V5fSBtaXNtYXRjaDogJHtpbm5lckluc3BlY3Rpb24uZmFpbHVyZVJlYXNvbn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gbmVzdGVkIG9iamVjdCBsaXRlcmFscyBpbnRvIG1vcmUgZGVlcCBvYmplY3QgbWF0Y2hlcnMsIGlmIGFwcGxpY2FibGVcbiAgICAgKlxuICAgICAqIE9iamVjdCBsaXRlcmFscyBpbiBsaXN0cyBhcmUgYWxzbyB0cmFuc2Zvcm1lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwTWF0Y2hlckZyb21PYmplY3RMaXRlcmFsKG5lc3RlZFBhdHRlcm46IGFueSk6IGFueSB7XG4gICAgICBpZiAoaXNPYmplY3QobmVzdGVkUGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBPYmplY3RMaWtlKG5lc3RlZFBhdHRlcm4pO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmVzdGVkUGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdHRlcm4ubWFwKGRlZXBNYXRjaGVyRnJvbU9iamVjdExpdGVyYWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lc3RlZFBhdHRlcm47XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFpbE1hdGNoZXIoaW5zcGVjdGlvbiwgZXJyb3JzLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBPdmVycmlkZSB0b0pTT04gc28gdGhhdCBvdXIgZXJyb3IgbWVzc2FnZXMgcHJpbnQgYW4gcmVhZGFibGUgdmVyc2lvbiBvZiB0aGlzIG1hdGNoZXJcbiAgLy8gKHdoaWNoIHdlIHByb2R1Y2UgYnkgZG9pbmcgSlNPTi5zdHJpbmdpZnkoKSBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUpLlxuICByZXQudG9KU09OID0gKCkgPT4gKHsgW2RlZXAgPyAnJGRlZXBPYmplY3RMaWtlJyA6ICckb2JqZWN0TGlrZSddOiBwYXR0ZXJuIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1hdGNoIGV4YWN0bHkgdGhlIGdpdmVuIHZhbHVlXG4gKlxuICogVGhpcyBpcyB0aGUgZGVmYXVsdCwgeW91IG9ubHkgbmVlZCB0aGlzIHRvIGVzY2FwZSBmcm9tIHRoZSBkZWVwIGxlbmllbnQgbWF0Y2hpbmdcbiAqIG9mIGBkZWVwT2JqZWN0TGlrZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdFZhbHVlKGV4cGVjdGVkOiBhbnkpOiBQcm9wZXJ0eU1hdGNoZXIge1xuICBjb25zdCByZXQgPSAodmFsdWU6IGFueSwgaW5zcGVjdGlvbjogSW5zcGVjdGlvbkZhaWx1cmUpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gbWF0Y2hMaXRlcmFsKHZhbHVlLCBleHBlY3RlZCwgaW5zcGVjdGlvbik7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGUgdG9KU09OIHNvIHRoYXQgb3VyIGVycm9yIG1lc3NhZ2VzIHByaW50IGFuIHJlYWRhYmxlIHZlcnNpb24gb2YgdGhpcyBtYXRjaGVyXG4gIC8vICh3aGljaCB3ZSBwcm9kdWNlIGJ5IGRvaW5nIEpTT04uc3RyaW5naWZ5KCkgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlKS5cbiAgcmV0LnRvSlNPTiA9ICgpID0+ICh7ICRleGFjdFZhbHVlOiBleHBlY3RlZCB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBBIG1hdGNoZXIgZm9yIGEgbGlzdCB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgZ2l2ZW4gZWxlbWVudHMgaW4gYW55IG9yZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVdpdGgoLi4uZWxlbWVudHM6IGFueVtdKTogUHJvcGVydHlNYXRjaGVyIHtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gYW55dGhpbmcoKTsgfVxuXG4gIGNvbnN0IHJldCA9ICh2YWx1ZTogYW55LCBpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWlsTWF0Y2hlcihpbnNwZWN0aW9uLCBgRXhwZWN0IGFuIGFycmF5IGJ1dCBnb3QgJyR7dHlwZW9mIHZhbHVlfSdgKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmUgPSBsb25nZXN0RmFpbHVyZSh2YWx1ZSwgZWxlbWVudCk7XG4gICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICByZXR1cm4gZmFpbE1hdGNoZXIoaW5zcGVjdGlvbiwgYEFycmF5IGRpZCBub3QgY29udGFpbiBleHBlY3RlZCBlbGVtZW50LCBjbG9zZXN0IG1hdGNoIGF0IGluZGV4ICR7ZmFpbHVyZVswXX06ICR7ZmFpbHVyZVsxXX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiAnbnVsbCcgaWYgdGhlIG1hdGNoZXIgbWF0Y2hlcyBhbnl3aGVyZSBpbiB0aGUgYXJyYXksIG90aGVyd2lzZSB0aGUgbG9uZ2VzdCBlcnJvciBhbmQgaXRzIGluZGV4XG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9uZ2VzdEZhaWx1cmUoYXJyYXk6IGFueVtdLCBtYXRjaGVyOiBhbnkpOiBbbnVtYmVyLCBzdHJpbmddIHwgbnVsbCB7XG4gICAgICBsZXQgZmFpbDogW251bWJlciwgc3RyaW5nXSB8IG51bGwgPSBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbm5lckluc3BlY3Rpb24gPSB7IC4uLmluc3BlY3Rpb24sIGZhaWx1cmVSZWFzb246ICcnIH07XG4gICAgICAgIGlmIChtYXRjaChhcnJheVtpXSwgbWF0Y2hlciwgaW5uZXJJbnNwZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhaWwgPT09IG51bGwgfHwgaW5uZXJJbnNwZWN0aW9uLmZhaWx1cmVSZWFzb24ubGVuZ3RoID4gZmFpbFsxXS5sZW5ndGgpIHtcbiAgICAgICAgICBmYWlsID0gW2ksIGlubmVySW5zcGVjdGlvbi5mYWlsdXJlUmVhc29uXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhaWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIE92ZXJyaWRlIHRvSlNPTiBzbyB0aGF0IG91ciBlcnJvciBtZXNzYWdlcyBwcmludCBhbiByZWFkYWJsZSB2ZXJzaW9uIG9mIHRoaXMgbWF0Y2hlclxuICAvLyAod2hpY2ggd2UgcHJvZHVjZSBieSBkb2luZyBKU09OLnN0cmluZ2lmeSgpIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSkuXG4gIHJldC50b0pTT04gPSAoKSA9PiAoeyAkYXJyYXlDb250YWluaW5nOiBlbGVtZW50cy5sZW5ndGggPT09IDEgPyBlbGVtZW50c1swXSA6IGVsZW1lbnRzIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1hdGNoZXMgYW55dGhpbmdcbiAqL1xuZnVuY3Rpb24gYW55dGhpbmcoKSB7XG4gIGNvbnN0IHJldCA9ICgpID0+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgcmV0LnRvSlNPTiA9ICgpID0+ICh7ICRhbnl0aGluZzogdHJ1ZSB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBgc3VwZXJPYmpgIGlzIGEgc3VwZXItb2JqZWN0IG9mIGBvYmpgLlxuICpcbiAqIEEgc3VwZXItb2JqZWN0IGhhcyB0aGUgc2FtZSBvciBtb3JlIHByb3BlcnR5IHZhbHVlcywgcmVjdXJzaW5nIGludG8gc3ViIHByb3BlcnRpZXMgaWYgYGBhbGxvd1ZhbHVlRXh0ZW5zaW9uYGAgaXMgdHJ1ZS5cbiAqXG4gKiBBdCBhbnkgcG9pbnQgaW4gdGhlIG9iamVjdCwgYSB2YWx1ZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjaGVjayB0aGF0IHBhcnRpY3VsYXIgZmllbGQuXG4gKiBUaGUgdHlwZSBvZiBhIG1hdGNoZXIgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBQcm9wZXJ0eU1hdGNoZXIuXG4gKlxuICogQGRlcHJlY2F0ZWQgLSBVc2UgYG9iamVjdExpa2VgIG9yIGEgbGl0ZXJhbCBvYmplY3QgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwZXJPYmplY3Qoc3VwZXJPYmo6IGFueSwgcGF0dGVybjogYW55LCBlcnJvcnM6IHN0cmluZ1tdID0gW10sIGFsbG93VmFsdWVFeHRlbnNpb246IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICBjb25zdCBtYXRjaGVyID0gYWxsb3dWYWx1ZUV4dGVuc2lvbiA/IGRlZXBPYmplY3RMaWtlKHBhdHRlcm4pIDogb2JqZWN0TGlrZShwYXR0ZXJuKTtcblxuICBjb25zdCBpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSA9IHsgcmVzb3VyY2U6IHN1cGVyT2JqLCBmYWlsdXJlUmVhc29uOiAnJyB9O1xuICBjb25zdCByZXQgPSBtYXRjaChzdXBlck9iaiwgbWF0Y2hlciwgaW5zcGVjdGlvbik7XG4gIGlmICghcmV0KSB7XG4gICAgZXJyb3JzLnB1c2goaW5zcGVjdGlvbi5mYWlsdXJlUmVhc29uKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFdoYXQgcGFydCBvZiB0aGUgcmVzb3VyY2UgdG8gY29tcGFyZVxuICovXG5leHBvcnQgZW51bSBSZXNvdXJjZVBhcnQge1xuICAvKipcbiAgICogT25seSBjb21wYXJlIHRoZSByZXNvdXJjZSdzIHByb3BlcnRpZXNcbiAgICovXG4gIFByb3BlcnRpZXMsXG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBlbnRpcmUgQ2xvdWRGb3JtYXRpb24gY29uZmlnXG4gICAqXG4gICAqIChpbmNsdWRpbmcgVXBkYXRlQ29uZmlnLCBEZXBlbmRzT24sIGV0Yy4pXG4gICAqL1xuICBDb21wbGV0ZURlZmluaXRpb25cbn1cblxuLyoqXG4gKiBXaGV0aGVyIGEgdmFsdWUgaXMgYSBjYWxsYWJsZVxuICovXG5mdW5jdGlvbiBpc0NhbGxhYmxlKHg6IGFueSk6IHggaXMgKCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSB7XG4gIHJldHVybiB4ICYmIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogV2hldGhlciBhIHZhbHVlIGlzIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4OiBhbnkpOiB4IGlzIG9iamVjdCB7XG4gIC8vIEJlY2F1c2UgYHR5cGVvZiBudWxsID09PSAnb2JqZWN0J2AuXG4gIHJldHVybiB4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbiJdfQ==